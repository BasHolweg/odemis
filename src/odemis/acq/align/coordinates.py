# -*- coding: utf-8 -*-
"""
Created on 28 Nov 2013

@author: Kimon Tsitsikas

Copyright Â© 2012-2013 Kimon Tsitsikas, Delmic

This file is part of Odemis.

Odemis is free software: you can redistribute it and/or modify it under the
terms  of the GNU General Public License version 2 as published by the Free
Software  Foundation.

Odemis is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY;  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR  PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
Odemis. If not, see http://www.gnu.org/licenses/.
"""

from __future__ import division

import numpy

def FindCenterCoordinates(subimages):
    """
    For each subimage generated by DivideInNeighborhoods, detects the center 
    of the contained spot. Finally produces a list with the center coordinates 
    corresponding to each subimage.
    subimages (List of model.DataArray): List of 2D arrays containing pixel intensity
    returns (List of tuples): Coordinates of spot centers
    """
    number_of_subimages = subimages.__len__()

    # Pop each subimage from the list
    for i in xrange(number_of_subimages):
        subimage = subimages.pop(i)
        subimage_x, subimage_y = subimage.shape
        
        """
        # For any set of four pixels of indices {(i, j), (i+1, j), (i, j+1), (i+1, j+1)} calculate
        # the gradient at the midpoint
        dIdu = subimage[1:subimage_x - 1, 2:subimage_y] - subimage[2:subimage_x, 1:subimage_y - 1]
        dIdv = subimage[1:subimage_x - 1, 1:subimage_y - 1] - subimage[2:subimage_x, 2:subimage_y]
        
        #The slope of the gradient at the midpoint in the xy coordinate system
        m = -(dIdv + dIdu) / (dIdu - dIdv)
        
        # x_m = tile([(-(subimage_y-1)/2.0+0.5):((subimage_y-1)/2.0-0.5)],(subimage_x-1,1))
        """
        # to be provided
        m = numpy.array()
        b = numpy.array()
        w = numpy.array()

        wm2p1 = w / (m * m + 1)
        sum_wm2p1 = numpy.sum(wm2p1)
        sum_mmwm2p1 = numpy.sum(m * m * wm2p1)
        sum_mwm2p1 = numpy.sum(m * wm2p1)
        sum_mbwm2p1 = numpy.sum(m * b * wm2p1)
        sum_bwm2p1 = numpy.sum(b * wm2p1)
        det = sum_mwm2p1 * sum_mwm2p1 - sum_mmwm2p1 * sum_wm2p1
        #relative to image center
        xc = (sum_mbwm2p1 * sum_wm2p1 - sum_mwm2p1 * sum_bwm2p1) / det
        yc = (sum_mbwm2p1 * sum_mwm2p1 - sum_mmwm2p1 * sum_bwm2p1) / det
        
    return subimage
