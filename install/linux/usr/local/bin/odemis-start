#!/bin/bash
# Start the gui and back-end in any case
# might ask to type password become root

. /etc/odemis.conf

export PYTHONPATH

# kill the GUI if it's already there
if pgrep -f $GUI > /dev/null; then
    echo "Found the GUI still running, killing it first..."
    /usr/bin/pkill -f $GUI
fi

# start the backend if not available
odemis-cli --check
status=$?
if [ $status -ne 0 ]; then
    # backend not responding or dead
    if [ $status -gt 2 ]; then
        echo "Warning: failed to check status of back-end"
    fi
    
    # install cgroup, for memory protection
    if [ ! -d /sys/fs/cgroup/memory/odemisd -a -x /usr/bin/cgcreate ]; then
        echo "Creating cgroup"
        sudo /usr/bin/cgcreate -a :odemis -g memory:odemisd
    fi
    
    # kill the current backend
    sudo /usr/bin/pkill -f $BACKEND

    # start a new one
    echo -n "Starting back-end.."
    
    # odemisd likes to start as root to be able to create /var/run files, but then
    # drop its priviledges to the odemis group
    # use sudo background mode to be sure it won't be killed at the end
    sudo -b odemisd --daemonize --log-level=2 --log-target "$LOGFILE" "$MODEL"
    status=$?
    if [ $status -ne 0 ]; then
        echo " failed"
        exit 1
    fi
    echo "."
    
    # Display the log while starting (and automatically quit when this script ends)
    /usr/bin/tail -n 0 -f "$LOGFILE" --pid=$$ &
    
    # For some drivers, initialisation can be pretty long
    sleep 5
    
    # Check (and synchronise)
    if odemis-cli --check; then
        echo "Back-end successfully started"
    else
        echo "Back-end failed to start."
#        echo "The last error messages were:"
#        /usr/bin/tail -n 50 "$LOGFILE" | /bin/grep --color -iE "(ERROR|Exception)"
		echo "For more log messages see file $LOGFILE"
		read -p "Press [Enter] to quit..."
        exit 1
    fi
fi

# start the GUI
odemis-gui
