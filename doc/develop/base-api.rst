****************************************
Basic objects of the component framework
****************************************


Component
=========
This is the generic type for representing a component. The subtypes are typical.

.. py:class:: Component(name[, parent=None][, children=None])

    This is the generic type for representing a component. The subtypes are typical.

.. py:attribute:: name 
    
    *(ro, str)* Name to be displayed/understood by the user (not to be used by the software to adapt the behaviour).


.children (ro, dict str → Component): list of children provided by the driver. Filled in at initialisation by the device driver.

.parent (ro, Component or None): component which provides this HwComponent. It has to be filled in at the same time as children.

.. TODO:

    How to explicitly support multiple parents? The problem is that then
    it can create all sort of problems with cyclic dependency. For now the 
    implementation supports it a bit (because we need it), but this attribute
    points to only one of the parents.

.. py:method:: terminate()
    
    Stops the component, and frees the ressources it uses. After a call to this 
    method, it is invalid to call any other method, or access attributes of the
    instance. It is only possible to call this method again, and this is case it
    will do nothing.



DataFlow
========
Represent a (large) read-only data set which is generated by a hardware. They are provided by Detectors.
.parent : the component which owns this data-flow.
.get(): acquire and returns the data from the detector. It returns a DataArray, which is an numpy.ndarray (containing the shape and format information) with a special attribute 'metadata' which is a dict (containing str → standard values representing metadata information to describe the precise information on how the data was acquired). See updateMetadata() and getMetadata().
TODO: should there be a timeout argument to specify the maximum time it's possible to wait? (or this is done always, with the timeout selected depending on the hardware). => doesn't seem very necessary after usage.
TODO: maybe allow to .get several data in a row? Useful for example when doing spectrum acquisition.
Note: For implementation of DataArray see http://docs.scipy.org/doc/numpy/user/basics.subclassing.html#simple-example-adding-an-extra-attribute-to-ndarray .
Be aware that it mostly behaves like a normal ndarray, but in some corner cases (such as .min() returning a DataArray of empty shape, instead of a scalar), it might be safer to first cast it to an ndarray.
.subscribe(callback): registers a function (callable) which will receive new version of the data every time it is available with the metadata. The format of the callback is callback(dataflow, dataarray), with dataflow the dataflow which calls it and dataarray the new data coming (which should not be modified, as other subscribers might receive the same object). It returns nothing.
TODO: optionally a “recommended update rate” which indicates how often we want data update maximum?
.unsubscribe(callback): unregister a given callback. Can be called from the callback itself.
.start_generate(): internal to the data-flow, it is called when the first subscriber arrives.
.stop_generate(): internal to the data-flow, it is called when the last subscriber is gone.
To change the properties of the data returned by get or sent to the callback, the client can use the properties of the detector. For example, to change the binning of a camera to 2x2, one would do “camera.binning.value = 2”. This imply a callback might receive DataArray which changes of shape between two calls. Rationale: it would also be possible to set it as argument of get()/subscribe(), but then they would not have standard interface and it would be particularly hard to deal in case of multiple listeners.
.notify(DataArray): to be used only by the component owning the DataArray. It provides the new data to every subscriber.
.synchronizedOn(Event or None): indicates that the acquisition should start just after (as close as possible) when the event happens. It can only wait for one event, or none at all (if None is passed).
Note on mix and simultaneous usage of get(), subscribe() and attribute update
Clients should be able to use simultaneously one data-flow without noticing that there are other clients receiving the data. However, synchronisation with attribute updates is not ensured when there are multiple clients.
When only one client accesses a detector, if it update some attributes and later get() or subscribe() to the data-flow, it is ensured that the attributes have been applied before the image acquisition. During acquisition, update to attributes are applied before the start of the next image acquisition. This means that the very next image received by the client is an image acquired with the previous attribute settings, as it was already started to be acquired at the moment the attributes were updated.
When a data-flow is already being accessed by a client, and a second client requests an image, it will obtain the very next image acquired (which acquisition might have started before the second client requested it). This also means that if the second client first update attributes, and then request an image, the image received has not been acquired with the new attributes, only the second image received will be. So whenever acquiring an image where the attributes are important, the client should confirm the attributes with the metadata of the received image, and if they haven't been applied yet, request another image.
The rationale for this behaviour is that other ways would either involve unique access (which is more complex to use and can easily block the whole system is one client is not responsive), or cancellation of acquisition and synchronisation of attribute updates which would not improve acquisition speed (and could even starve the flow is the attributes keep changing).
Note: when creating a detector component, make sure that putting a very big exposure time cannot block the acquisition forever. At least, when there is no more subscribers (stop_generate()), it should stop acquisition immediately.

To sum up:
VA changes: if possible, only recorded internally, and applied before acquiring the next image (if values are different from previous ones). If not possible otherwise, apply immediately the changes, during the acquisition.
Get:
Equivalent to a flow acquisition for only one image and synchronous.
Flow acquisition:
If not acquisition going on: start_generate() will start acquiring images.
If already flow acquisition: nothing (should be already handled by start_generate)

Event
=====

Object used to indicate that a specific event has happened. It allows to wait for an event before doing an action. For example an scanning emitter moving to the next position (pixel), the end of a complete line scan. There is only one owner (generator) of the event, but there might be multiple listeners. Each listener has a separate queue, which ensures it will never miss the fact an event has happened.
.trigger() : indicates an event has just occurred. Only to be done by the owner of the event.
.wait(object, timeout=None): wait for the event to happen. Returns either True (the event has happened) or False (timeout, or the the object is no more synchronised on this event). It automatically remove from the listener queue the fact the event has happened.
.clear(object): empties the queue of events.
.subscribe(object): add the object as listener to the events. TODO: allow to give a callback function, in which case it will just call the function, instead of having to do a wait? It should allow to avoid the scheduling latency (~1ms). Or maybe just a callback function, (and declare it as @oneway), then it's still extensible later to use the queue mechanism if object is not callable (e.g, just self).
.unsubscribe(object): remove the object as listener.

Future
======

All asynchronous functions return a Future. It's an object which must follow/inherit the concurrent.futures.Future class of python. See http://docs.python.org/dev/library/concurrent.futures.html for more information.
At least it should have these methods:
.cancel()
.running()
.done()
.result(timeout=None) : wait for the function to finish, at most timeout seconds and return its result.
.add_done_callback(fn)

Note that every method returning a future must be explicitly indicated. This is done by decorating them with @isasync (model.isasync). Although from a behavioural point of view, futures will work even if the function is not decorated, it will have a very big performance penalty when used remotely. The only exception is in case of the special model.InstantaneousFuture which represents an action already completed at the time of the function return. In this case, it is fine to not decorate the function specifically.
Note also that the implementation we have of the Future slightly differ from the official specification because cancel() might work by stopping in the middle the execution (without necessarily cancelling the work done so far).
ProgressiveFuture
We have an extension to Future, called ProgressiveFuture, which provides also information about the execution progress. It has one more methods for the user:
.add_update_callback(fn)
And also two more methods for the executor to give the information:
.set_start_time(t)
.set_stop_time(t)

Vigilant Attributes
===================

Vigilant Attributes represent a specific property of a hardware device. Typically they are used to configure the device to a specific mode (e.g., change the resolution of a camera, change the speed of a motor) or obtain information on the device (e.g., current temperature of a CCD sensor, internal pressure) in which case the property might be read-only.
All the calls are synchronous: at the end of the call, the hardware property represented has be modified and or an exception was raised due to an error.
They are observable: it has a set of observers (python callables) which are called whenever the value change.
.value : getter/setter for the value. When setting a property to a non-available value (too big, not in the enumerated value, incompatible with the other values), depending on the implementation, the setter can either decide to silently set the value to a valid one, modify other properties for this one to be allowed (then observers of these other properties get notified), or raise an exception.
.unit (str): The unit of the value. Whenever possible the values should be expressed in standard SI value (m, rad, C, s). Never express anything in multiples of a official unit (e.g., never put anything in nm).
.subscribe(callback): method to be called when the value changes
.unsubscribe(callback): method to be called to not be notified any more
When a new value is set, subscribers will receive a notification once the value has been changed. If the previous value, the requested value, and the new value are all identical, no notification is sent.
One important difference with the normal Python behaviour, is that the subscriber callback must always be kept referenced to be called (i.e., the VigilandAttribute only keeps a weak reference to the callback). In particular, this means that lambda functions must be kept explicitly in reference by the subscriber (for example, in a list). Rationale: this permits to have objects subscribed to a VA be easily garbage collected, without the developer having to ensure that every VA is unsubscribed when the object is not used. That also forces the subscribers to always be able to unsubscribe (as unsubscribe uses the callback as identifier).
FloatVA:
.value: can only contain a float
IntegerVA:
.value: can only contain an int
BooleanVA:
.value: can only contain an bool
StringVA:
.value: can only contain a str
ListVA:
.value: contains an ordered list of values which can be of any type (including of different type for each value as long as they are all continuous or all enumerated). It can be of fixed size (tuple) or might change size (list). When modifying a the value, it should always be treated like a tuple: any modification must be done on a copy and then the value is set to this copy (Rationale: because it is pretty hard to detect changes of a list).

The following two can be inherited from any of the properties:
ContinuousVA:
.range (2-tuple): minimum and maximum possible value. If it's a ListVA with a fixed number of values, it returns a tuple for each value.
EnumeratedVA:
.choices: set of possible values. If it's a ListVA with a fixed number of values it returns a set for each value.
ResolutionVA:
.value: can only contain a 2-tuple int
.range (2-tuple of 2-tuple int): minimum values for each item in the value, and maximum values for each item in the value.

.range and .choices can be modified at runtime, but only by the owner of the VA and only if the current value is compatible. This should be avoided whenever possible because no notification is sent to the subscribers.
When creating a VigilantAttribute (__init__()), it is possible to define a setter. It's a callable that is called every time the value is set, which receives the new value as argument and returns the actual value to be set to. It is typically used to allow modifying the underlying hardware value and return the actual value set.



Component Framework
===================

Each part of the software runs as a separate component. Components are isolated in containers, which are actually a unix process listening for requests. In most cases this is transparent to the development. However, there are a couple of guidelines and restrictions.
To get the microscope component, the special model.getMicroscope() function will return the microscope component wherever it is (as long as it is available). To access a specific component it's also possible to use model.getObject(container_name, component_name) but it requires to know the name of the container. Only the name of the main back-end container is sure: model.BACKEND_NAME. In practice, most components are either on the back-end container or on a separate container with the same name as the component.
To stop the system, all the components should be terminated (.terminate()) and then the back-end container can be terminated (.terminate()). This container will ensure that all the other containers are also terminated.
All the methods of a component are directly accessible remotely. However, not all attributes are remotely accessible. Only the Data-flows, Vigilant attributes, and roattributes are automatically shared. roattributes are read-only attributes which value must not be modified after initialisation. They are declared with the @roattribute decorator (like a property). Methods which return a future should be decorated with @isasync (it will work without it, but much slower). Methods which do not return any value and for which the caller never needs to know when it's finished can be decorated @oneway to improve performance.
When accessing an object running in the same container, a normal python object is always returned automatically. TODO: probably needs more tweaking to be really true, like in the case of accessing .parent of a remote object.
In addition, when a component is accessed from a separate container (e.g., when accessing a device driver from the GUI) the actual python object is a proxy to the real component. While in most cases this is transparent, you should be aware of:
isinstance() (and everything related to class) will not work as expected because it will always say the object is a Proxy. So relying on class type to take a decision will not work. It's recommended to rely on the .capabilities attribute. TODO create .capabilities. Create also a ._realclass_ on proxy?
duck typing doesn't work either: when accessing an non-existing attributes on a object always returns an object (Pyro4.core._RemoteMethod). This is an inherent limitation of proxying in python, as everything is dynamic, it's not possible to know if an attribute actually exists on an object before actually trying (and if it's a method, it needs to be called). It is recommended to rely on the .capabilities attribute, or if an attribute is expected compare the type of the attribute to _RemoteMethod.

